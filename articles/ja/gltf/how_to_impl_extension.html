<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>GLTF &#25313;&#24373;&#12392;&#12399; </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="GLTF &#25313;&#24373;&#12392;&#12399; ">
    <meta name="generator" content="docfx 2.58.2.0">
    
    <link rel="shortcut icon" href="../../../favicon.ico">
    <link rel="stylesheet" href="../../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../../styles/docfx.css">
    <link rel="stylesheet" href="../../../styles/main.css">
    <meta property="docfx:navrel" content="../../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../../index.html">
                <img id="logo" class="svg" src="../../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">

<p><code>UniVRM-0.63.2</code> から <code>UniGLTF</code> の構成が変わって、 <code>extensions</code> / <code>extras</code> の実装方法が変わりました。</p>
<h2 id="gltf-拡張とは">GLTF 拡張とは</h2>
<p><code>glTF</code> は各所に <code>extensions</code>, <code>extras</code> が定義してありその中身を拡張できます。</p>
<ul>
<li><code>extensions</code> (またはextras)</li>
<li><code>asset.extensions</code> (またはextras)</li>
<li><code>meshes[*].extensions</code> (またはextras)</li>
<li><code>materials[*].extensions</code> (またはextras)</li>
</ul>
<p>など。</p>
<p><code>extensions</code> はオフィシャルに仕様を策定して <code>JsonSchema</code> として公開します。</p>
<ul>
<li><a href="https://github.com/KhronosGroup/glTF/tree/master/extensions">https://github.com/KhronosGroup/glTF/tree/master/extensions</a></li>
</ul>
<p><code>extensions</code> は、<code>{ベンダー名}_{拡張名}</code> という命名規則です。
ベンダー名は、 <a href="https://github.com/KhronosGroup/glTF">https://github.com/KhronosGroup/glTF</a> に申し込んで登録できます。</p>
<p><code>extras</code> は登録せずにアプリケーション独自に拡張する場合に用います。仕組みは同じです。</p>
<blockquote>
<p>This enables glTF models to contain application-specific properties without creating a full glTF extension</p>
</blockquote>
<h2 id="unigltf-の-extensions">UniGLTF の extensions</h2>
<p><code>v0.63.0</code> 以前は、<code>GLTF 型</code> の <code>extensions</code> フィールドに、<code>GLTFExtensions</code> 型を定義して、<code>VRM</code> フィールドを定義するという方法をとっていました。</p>
<pre><code class="lang-cs">class VRM
{

}

class GLTFExtensions
{
    public VRM VRM;
}

class GLTF
{
    // すべての拡張の型をコンパイル時に知っている必要がある。動的に拡張できない
    public GLTFExtensions extensions;
}
</code></pre>
<p>この設計だと GLTF と拡張を別ライブラリとして分離することができませんでした。</p>
<p><code>v0.63.1</code> から設計を変更して、すべての <code>extensions/extras</code> に同じ型の入れ物を使うように変更しました。
UniGLTF は <code>import/export</code> の具体的な内容を知らずに中間データの入れ物として扱います。</p>
<pre><code class="lang-cs">// extensions / extras の入れ物として使う型
// 実行時は、 glTFExtensionImport / glTFExtensionExport を使う
public abstract class glTFExtension
{

}

class GLTF
{
    // UniGLTFは具体的な型を知らない。利用側が処理(serialize/deserialize)する
    public glTFExtension extensions;
}
</code></pre>
<h2 id="unigltf-の拡張の書き方">UniGLTF の拡張の書き方</h2>
<p>拡張は、以下の部品要素から作れます。</p>
<ul>
<li>名前(JsonPath)。例: <code>extensions.VRM</code>, <code>materials[*].extensions.KHR_materials_unlit</code></li>
<li>拡張の型。<code>T型</code></li>
<li>デシリアライザー(import)。 <code>jsonバイト列 =&gt; T型</code></li>
<li>シリアライザーexport)。<code>T型 =&gt; jsonバイト列</code></li>
</ul>
<h3 id="jsonpath-と-型を決める">JSONPATH と 型を決める</h3>
<pre><code class="lang-C#">// 型
class GoodMaterial
{
    // `materials[*].extensions.CUSTOM_materials_good`
    public const string EXTENSION_NAME = &quot;CUSTOM_materials_good&quot;;

    public int GoodValue;
}
</code></pre>
<h3 id="import">import</h3>
<pre><code class="lang-C#">GoodMaterial DeserializeGoodMaterial(ListTreeNode&lt;JsonValue&gt; json)
{
    // デシリアライズ。手で書くかコード生成する(後述)
}

// ユーティリティ関数例
bool TryGetExtension&lt;T&gt;(UniGLTF.glTFExtension extension, string key, Func&lt;ListTreeNode&lt;JsonValue&gt;, T&gt; deserializer, out T value)
{
    if(material.extensions is UniGLTF.glTFExtensionsImport import)
    {
        // null check 完了
        foreach(var kv in import.ObjectItems())
        {
            if(kv.key.GetString()==key)
            {
                value = Deserialize(kv.Value);
                return true;
            }
        }
    }

    value = default;
    return false;
}

void ImportMaterial(UniGLTF.glTFMaterial material)
{
    // material の処理に割り込んで
    if(TryGetExtension(material.extension, GoodMaterial.EXTENSION_NAME, DeserializeGoodMaterial, out GoodMaterial good))
    {
        // good material 独自の処理
    }
}
</code></pre>
<h3 id="export">export</h3>
<pre><code class="lang-cs">void SerializeGoodMaterial(UniJSON.JsonFormatter f, GoodMaterial value)
{
    // シリアライズ。手で書くかコード生成する(後述)
}

// ユーティリティ関数例
public ArraySegment&lt;byte&gt; SerializeExtension&lt;T&gt;(T value, Func&lt;T, ArraySegment&lt;byte&gt;&gt; serialize)
{
    var f = new UniJSON.JsonFormatter();
    serialize(f, value);
    return f.GetStoreBytes();
}

void ExportGoodMaterial(UniGLTF.glTFMaterial material, GoodMaterial good)
{
    // material の処理に割り込んで
    if(!(material.extensions is UniGLTF.glTFExtensionsExport export))
    {
        // 無かった。新規作成
        export = new UniGLTF.glTFExtensionsExport();
        material.extensions = export;
    }

    var bytes = SerializeExtension(good, SerializeGoodMaterial);
    export.Add(GoodMaterial.EXTENSION_NAME, bytes);
}
</code></pre>
<h2 id="実装例">実装例</h2>
<h3 id="gltf-gltf全体">GLTF: GLTF全体</h3>
<p><code>C#の型からコード生成</code></p>
<ul>
<li><code>Assets\UniGLTF\Runtime\UniGLTF\Format\GltfSerializer.g.cs</code></li>
<li><code>Assets\UniGLTF\Runtime\UniGLTF\Format\GltfDeserializer.g.cs</code></li>
</ul>
<p>ジェネレーターの呼び出しコード</p>
<ul>
<li><code>Assets\UniGLTF\Editor\UniGLTF\Serialization\SerializerGenerator.cs</code></li>
<li><code>Assets\UniGLTF\Editor\UniGLTF\Serialization\DeserializerGenerator.cs</code></li>
</ul>
<p>生成コードの呼び出し</p>
<h3 id="gltf-meshesextrastargetnames">GLTF: <code>meshes[*].extras.targetNames</code></h3>
<p><code>コード生成せずに手書き</code></p>
<ul>
<li><code>Assets\UniGLTF\Runtime\UniGLTF\Format\ExtensionsAndExtras\gltf_mesh_extras_targetNames.cs</code></li>
</ul>
<p>生成コードの呼び出し</p>
<h3 id="gltf-materialsextensionskhr_materials_unlit">GLTF: <code>materials[*].extensions.KHR_materials_unlit</code></h3>
<p><code>コード生成せずに手書き</code></p>
<ul>
<li><code>Assets\UniGLTF\Runtime\UniGLTF\Format\ExtensionsAndExtras\KHR_materials_unlit.cs</code></li>
</ul>
<p>生成コードの呼び出し</p>
<h3 id="gltf-materialsextensionskhr_texture_transform">GLTF: <code>materials[*].extensions.KHR_texture_transform</code></h3>
<p><code>コード生成せずに手書き</code></p>
<ul>
<li><code>Assets\UniGLTF\Runtime\UniGLTF\Format\ExtensionsAndExtras\KHR_texture_transform.cs</code></li>
</ul>
<p>生成コードの呼び出し</p>
<ul>
<li><a href="https://github.com/vrm-c/UniVRM/blob/master/Assets/UniGLTF/Runtime/UniGLTF/IO/MaterialImporter.cs#L296">https://github.com/vrm-c/UniVRM/blob/master/Assets/UniGLTF/Runtime/UniGLTF/IO/MaterialImporter.cs#L296</a></li>
<li><a href="https://github.com/vrm-c/UniVRM/blob/master/Assets/UniGLTF/Runtime/UniGLTF/IO/MaterialExporter.cs#L193">https://github.com/vrm-c/UniVRM/blob/master/Assets/UniGLTF/Runtime/UniGLTF/IO/MaterialExporter.cs#L193</a></li>
</ul>
<h3 id="vrm0-extensionsvrm">VRM0: <code>extensions.VRM</code></h3>
<p><code>C#の型からコード生成</code></p>
<ul>
<li><code>Assets\VRM\Runtime\Format\VRMSerializer.g.cs</code></li>
<li><code>Assets\VRM\Runtime\Format\VRMDeserializer.g.cs</code></li>
</ul>
<p>ジェネレーターの呼び出しコード</p>
<ul>
<li><code>Assets\VRM\Editor\VRMSerializerGenerator.cs</code></li>
<li><code>Assets\VRM\Editor\VRMDeserializerGenerator.cs</code></li>
</ul>
<p>生成コードの呼び出し</p>
<ul>
<li><a href="https://github.com/vrm-c/UniVRM/blob/master/Assets/VRM/Runtime/IO/VRMImporterContext.cs#L41">https://github.com/vrm-c/UniVRM/blob/master/Assets/VRM/Runtime/IO/VRMImporterContext.cs#L41</a></li>
<li><a href="https://github.com/vrm-c/UniVRM/blob/master/Assets/VRM/Runtime/IO/VRMExporter.cs#L209">https://github.com/vrm-c/UniVRM/blob/master/Assets/VRM/Runtime/IO/VRMExporter.cs#L209</a></li>
</ul>
<h3 id="vrm1-extensionsvrmc_vrm-など">VRM1: <code>extensions.VRMC_vrm</code> など</h3>
<p><code>JsonSchemaからコード生成</code></p>
<p>5つの Extensions に分かれたので個別に作成。
ささる場所(JsonPath)が違うのに注意。</p>
<h4 id="extensionsvrmc_vrm"><code>extensions.VRMC_vrm</code></h4>
<ul>
<li><code>Assets\VRM10\Runtime\Format\VRM</code></li>
</ul>
<h4 id="materialsextensionsvrmc_materials_mtoon"><code>materials[*].extensions.VRMC_materials_mtoon</code></h4>
<ul>
<li><code>Assets\VRM10\Runtime\Format\MaterialsMToon</code></li>
</ul>
<h4 id="nodesextensionsvrmc_node_collider"><code>nodes[*].extensions.VRMC_node_collider</code></h4>
<ul>
<li><code>Assets\VRM10\Runtime\Format\NodeCollider</code></li>
</ul>
<h4 id="extensionsvrmc_springbone"><code>extensions.VRMC_springBone</code></h4>
<ul>
<li><code>Assets\VRM10\Runtime\Format\SpringBone</code></li>
</ul>
<h4 id="extensionsvrmc_vrm_constraints"><code>extensions.VRMC_vrm_constraints</code></h4>
<ul>
<li><code>Assets\VRM10\Runtime\Format\Constraints</code></li>
</ul>
<h4 id="ジェネレーターの呼び出しコード">ジェネレーターの呼び出しコード</h4>
<ul>
<li><code>Assets\VRM10\Editor\GeneratorMenu.cs</code></li>
</ul>
<h4 id="生成コードの呼び出し">生成コードの呼び出し</h4>
<h2 id="コード生成">コード生成</h2>
<p>JSON と C# の型との シリアライズ/デシリアライズは定型コードになるので、ジェネレーターがあります。
C# の型から生成するものと、JsonSchema から C# の型とともに生成するものがあります。</p>
<h3 id="c-の型から生成">C# の型から生成</h3>
<h4 id="シリアライザー">シリアライザー</h4>
<p>ジェネレーターを呼び出すコードを作成します。</p>
<ul>
<li>元になる型</li>
<li>出力先</li>
</ul>
<p>の２つを決めます。static関数を生成するので、namespace と static class で囲ってあげます。</p>
<p>例</p>
<ul>
<li><code>Assets\UniGLTF\Editor\UniGLTF\Serialization\SerializerGenerator.cs</code></li>
</ul>
<pre><code class="lang-cs">using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Text;
using UniJSON;
using UnityEditor;
using UnityEngine;

namespace UniGLTF
{
    public static class SerializerGenerator
    {
        const BindingFlags FIELD_FLAGS = BindingFlags.Instance | BindingFlags.Public;

        const string Begin = @&quot;// Don't edit manually. This is generaged. 
using System;
using System.Collections.Generic;
using UniJSON;

namespace UniGLTF {

    static public class GltfSerializer
    {

&quot;;

        const string End = @&quot;
    } // class
} // namespace
&quot;;

        static string OutPath
        {
            get
            {
                return Path.Combine(UnityEngine.Application.dataPath,
                &quot;UniGLTF/UniGLTF/Scripts/IO/GltfSerializer.g.cs&quot;);
            }
        }

        [MenuItem(UniGLTFVersion.MENU + &quot;/GLTF: Generate Serializer&quot;)]
        static void GenerateSerializer()
        {
            var info = new ObjectSerialization(typeof(glTF), &quot;gltf&quot;, &quot;Serialize_&quot;);
            Debug.Log(info);

            using (var s = File.Open(OutPath, FileMode.Create))
            using (var w = new StreamWriter(s, new UTF8Encoding(false)))
            {
                w.Write(Begin);
                info.GenerateSerializer(w, &quot;Serialize&quot;);
                w.Write(End);
            }

            Debug.LogFormat(&quot;write: {0}&quot;, OutPath);
            UnityPath.FromFullpath(OutPath).ImportAsset();
        }
    }
}
</code></pre>
<h4 id="デシリアライザー">デシリアライザー</h4>
<p>ジェネレーターを呼び出すコードを作成します。</p>
<ul>
<li>元になる型</li>
<li>出力先</li>
</ul>
<p>の２つを決めます。static関数を生成するので、namespace と static class で囲ってあげます。</p>
<p>例</p>
<ul>
<li><code>Assets\UniGLTF\Editor\UniGLTF\Serialization\DeserializerGenerator.cs</code></li>
</ul>
<pre><code class="lang-cs">using System.IO;
using System.Reflection;
using System.Text;
using UnityEditor;
using UnityEngine;

namespace UniGLTF
{
    /// &lt;summary&gt;
    /// Generate deserializer from ListTreeNode&lt;JsonValue&gt; to glTF using type reflection
    /// &lt;/summary&gt;
    public static class DeserializerGenerator
    {
        public const BindingFlags FIELD_FLAGS = BindingFlags.Instance | BindingFlags.Public;

        const string Begin = @&quot;// Don't edit manually. This is generaged. 
using UniJSON;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace UniGLTF {

public static class GltfDeserializer
{

&quot;;

        const string End = @&quot;
} // GltfDeserializer
} // UniGLTF 
&quot;;

        static string OutPath
        {
            get
            {
                return Path.Combine(UnityEngine.Application.dataPath,
                &quot;UniGLTF/UniGLTF/Scripts/IO/GltfDeserializer.g.cs&quot;);
            }
        }

        [MenuItem(UniGLTFVersion.MENU + &quot;/GLTF: Generate Deserializer&quot;)]
        static void GenerateSerializer()
        {
            var info = new ObjectSerialization(typeof(glTF), &quot;gltf&quot;, &quot;Deserialize_&quot;);
            Debug.Log(info);

            using (var s = File.Open(OutPath, FileMode.Create))
            using (var w = new StreamWriter(s, new UTF8Encoding(false)))
            {
                w.Write(Begin);
                info.GenerateDeserializer(w, &quot;Deserialize&quot;);
                w.Write(End);
            }

            Debug.LogFormat(&quot;write: {0}&quot;, OutPath);
            UnityPath.FromFullpath(OutPath).ImportAsset();
        }
    }
}
</code></pre>
<h4 id="キー出力の抑制">キー出力の抑制</h4>
<p><code>index</code> に無効な値として <code>-1</code> を入れる場合に、JSONではキーを出力しないとしたいことがあります。</p>
<p>TODO: <code>int?</code> にするべきだった</p>
<pre><code class="lang-cs">[JsonSchema(Minimum = 0)]
int index = -1;
</code></pre>
<p>のようにすることで、キーの出力を抑制できます。</p>
<pre><code class="lang-cs">    // 生成コードのキー出力例
    if(value.index&gt;=0){
</code></pre>
<p>何も付けないと</p>
<pre><code class="lang-cs">    // 出力制御無し
    if(true){
</code></pre>
<h4 id="enum-のエンコーディング">enum のエンコーディング</h4>
<p>enumの値の名前を文字列で使う、enumの値の数値を使うの2種類がありえます。
enumの場合はデフォルト値が無いので必須です。</p>
<pre><code class="lang-cs">[JsonSchema(EnumSerializationType = EnumSerializationType.AsInt)]
public glBufferTarget target;

[JsonSchema(EnumSerializationType = EnumSerializationType.AsLowerString)]
public ProjectionType type;
</code></pre>
<h3 id="jsonschemaから生成">JsonSchemaから生成</h3>
<p>VRM-1.0 の実装</p>
<p>TODO:</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/virtual-cast/UniVRM/blob/master/docfx/articles/ja/gltf/how_to_impl_extension.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../styles/main.js"></script>
  </body>
</html>
